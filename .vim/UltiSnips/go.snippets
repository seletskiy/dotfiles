global !p
from px.go import *
from px.util import *
from px.all import *
endglobal

snippet "^n" "func" brA
func $1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet "^s" "type struct" brA
`!p
if re.match("^([\w\[\]{}]*)$", t[2]):
	type_left = " "
	type_right = ""
else:
	type_left = " struct {\n\t"
	type_right = "\n}"
	if re.match("^\w+\(\)", t[2]):
		type_left = " interface {\n\t"
`type $1`!p snip.rv=type_left`$2`!p snip.rv=type_right`$0
endsnippet

priority 20
snippet "^p" "package" "snip.buffer.name.endswith('main.go')" brAe
package main

$0
endsnippet

priority 10
snippet "^p" "package" brA
package ${1:`!p snip.rv=guess_package_name_from_file_name(snip.fn)`}

$0
endsnippet

priority 1
snippet te "func Test"
func Test$1(t *testing.T) {
	$2
}
endsnippet

snippet i "if "
if ${1:`!p snip.rv=get_last_defined_var_for_snippet()`} {
	${2:${VISUAL}}
}
endsnippet

snippet ii "if <VISUAL>"
if ${VISUAL} {
	$2
}
endsnippet

snippet q "if err != nil"
if err != nil {
	return err
}
endsnippet

snippet qq "if err != nil"
if err != nil {
	return ${1:nil}, err
}
endsnippet


snippet qp "if err != nil panic"
if err != nil {
	panic(err)
}
endsnippet

snippet qn "if ... == nil"
if ${1:`!p snip.rv=get_last_defined_var_for_snippet()`} == nil {
	${0:${VISUAL}}
}
endsnippet

snippet r "return"
return 
endsnippet

snippet r "return" "re.match('^\s+if err ', get_prev_nonempty_line(snip.buffer, snip.line))" eb
return err
endsnippet

snippet p "panic" "re.match('^\s+if err ', get_prev_nonempty_line(snip.buffer, snip.line))" ebA
panic(err)
endsnippet

snippet fs "... string" i
$1 string
endsnippet

snippet exp "test expected"
actual := ${1:"Something"}
if actual != ${2:"Actual"} {
	t.Fatalf("unexpected %#v", actual)
}
endsnippet

snippet ci "const iota"
const (
	${1:CONSTANT} = iota$2
)
endsnippet

snippet ass "anon struct with fields" w
struct {
	$1
}{
	$2
}
endsnippet

snippet "((\w+)\s*(\w+)) js$" "json annotation" br
`!p snip.rv=match.group(1)` \`json:"${1:`!p
snip.rv=convert_camelcase_to_snakecase(match.group(2))`}"\`
endsnippet

snippet "^m" "func main" rbA
func main() {
	$2
}
endsnippet

snippet fas "anon struct"
${1:Name} struct {
	$2
}
endsnippet

snippet fi "field int" i
${1:Name} int
endsnippet

snippet fb "field bool" i
${1:Name} bool
endsnippet

snippet mp "map" i
map[${1:string}]${2:interface}
endsnippet

snippet msi "map[string]interface" w
map[string]interface{}
endsnippet

snippet w "switch"
switch ${1:`!p snip.rv=get_last_defined_var_for_snippet()`} {
case ${2:true}:
	$3
}
endsnippet

snippet ww "switch true"
switch {
case ${1}:
	$1
}
endsnippet

snippet f "for range"
for ${1:_}, ${2:val} := range ${3:`!p snip.rv=get_last_defined_var_for_snippet()`} {
	${0:${VISUAL}}
}
endsnippet

snippet p "log.Printf(%#v with filename"
log.Printf("`!p snip.rv=path+":"+str(vim.current.window.cursor[0])` %#v", $1)
endsnippet

snippet play "package main"
package main

import "fmt"

func main() {
	$1
}
endsnippet

snippet omit "omit section"
// OMIT
${0:${VISUAL}}
// END OMIT
endsnippet

snippet af "anon func" i
func($1) $2{
	${3:${VISUAL}}
}
endsnippet

snippet v "var ="
var $1 = 
endsnippet

snippet vr "var ("
var (
	${0:${VISUAL/(?m)^(\s*)var /$1/g}}
)
endsnippet

snippet snip.column "case"
case $1:
	$2
endsnippet

snippet c "continue" "re.match('^\s+if ', get_prev_nonempty_line(snip.buffer, snip.line))" eb
continue
endsnippet

snippet rn "return nil"
return nil
endsnippet

snippet u "append" i
${1:`!p snip.rv=get_last_defined_var_for_snippet()`} = append($1, $2)
endsnippet

snippet ms "make slice" i
make([]$1, ${2:0})
endsnippet

snippet mc "make chan" i
make(chan $1, ${2:0})
endsnippet

snippet mm "make map" i
make(map[${1:string}]${2:interface\{\}})
endsnippet

snippet nn "!= nil" i
${1:${VISUAL}} != nil
endsnippet

snippet if "interface" i
interface{}
endsnippet

snippet ts "type switch"
switch ${1:newVar} := ${2:checkVar}.(type) {
case ${3:Type}:
	$4
}
endsnippet

snippet , "return ... , nil" "is_return_argument(snip.buffer, snip.line, snip.column)" ie
, `!p if is_in_err_condition(vim.current.buffer, vim.current.window.cursor[0], vim.current.window.cursor[1]):
	snip.rv = "err"
else:
	snip.rv = "nil"`
endsnippet

snippet n, ", nil" i
nil, 
endsnippet

snippet o "forever"
for {
	$1
}
endsnippet

snippet ae "blah, err := "
${1:data}, err := 
endsnippet

snippet a "blah := "
${1:data} := 
endsnippet


snippet qt
if err != nil {
	t.Fatal(err)
}
endsnippet

snippet qf
if err != nil {
	log.Fatalf(\`$1: %s\`, $2, err)
}
endsnippet

snippet rt "return true"
return true
endsnippet

snippet rf "return false"
return false
endsnippet

snippet "^}(.)$" "define method" rwA
`!p snip.rv = "}\n\n"
`func (`!p snip.rv=' *'.join(extract_prev_method_binding_for_cursor())`) `!p snip.rv = match.group(1)`$1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet re "return errors.New"
return errors.New($1)
endsnippet

snippet y "error"
error
endsnippet

snippet lf "log.Printf"
log.Printf($1)
endsnippet

snippet ln "fmt.Println" bwA
`!p
left = '('
right = ')'
if " " in t[1] and not '"' in t[1]:
	left = '("'
	right = '")'
`fmt.Println`!p snip.rv=left`$1`!p snip.rv=right`
endsnippet

snippet td "todo"
// @TODO: 
endsnippet

snippet snip.line "last slice usage" i
${1:`!p snip.rv=get_previous_slice_usage()`}[$2]
endsnippet

snippet t "Description" b
var $1 = $2
endsnippet

snippet co "continue"
continue
endsnippet

snippet } "else" "is_if_bracket(snip.buffer, snip.line, snip.column)" ew
} else {
	$1
}
endsnippet

snippet i "if err != nil" "re.match('^\s+[^=]*err\s*:?=', snip.buffer[snip.line-1])" e
if err != nil {
	$1
}
endsnippet

snippet "(func\s.*\)\s+)([\w\d_\s\{\}\[\]\*\.]+),\s?([\w\d_\s\{\}\[\]\*\.]+)" "return multiple" r
`!p snip.rv=match.group(1)`(`!p snip.rv=match.group(2)`, `!p snip.rv=match.group(3)`)
endsnippet

snippet go "go func" b
go func() {
	${1:${VISUAL}}
}()
endsnippet

snippet "}(.)" "else" "is_if_bracket(snip.buffer, snip.line, snip.column-1)" rebA
} else {
	`!p snip.rv = match.group(1)`$1
}
endsnippet


snippet lp "log.Println" wA
`!p
left = '('
right = ')'
if " " in t[1] and not '"' in t[1]:
	left = '("'
	right = '")'
`log.Println`!p snip.rv=left`$1`!p snip.rv=right`
endsnippet

snippet X "la" b
return
endsnippet

post_jump "print(snip)"
snippet x "Description" b
$1: {
	$2
}
endsnippet

global !p
def get_program_name_from_docopt(text):
	matches = re.match('(.*)\s+[\d+.]+', text)
	if matches:
		return matches.group(1)
	else:
		return None

def add_usage(snip):
	goto_const();
	snip.expand_anon("""const usage = \`%s
	
$2
	
Usage:
	\$0 -h | --help
	$3

Options:
	-h --help  Show this help.
	$4
`
	
""" % (get_program_name_from_docopt(snip.tabstops[1].current_text),))
endglobal

post_jump "if snip.tabstop == 0: add_usage(snip)"
snippet do "docopt" b
args, err := docopt.Parse(
	strings.Replace(usage, "\$0", os.Args[0], -1),
	nil, true, "${1:1.0}", false,
)
if err != nil {
	panic(err)
}
endsnippet

global !p
def is_inside_docopt_section(snip, section):
	if not is_syntax_string(to_vim_cursor(snip.cursor)):
		return False

	match = match_higher_indent(snip.buffer, snip.cursor, '(?i)' + section)
	if not match:
		return False

	return True

def docopt_format_options(snip):
	match = match_higher_indent(snip.buffer, snip.cursor, '(?i)options')
	if not match:
		return

	usage_begins_at = match[1] + 1
	usage_ends_at = usage_begins_at
	longest_option = ''

	tab_width = int(vim.eval('&ts'))

	for line in snip.buffer[usage_begins_at:]:
		if line.strip() == '`':
			break
		option = parse_docopt_option(line, tab_width)
		if len(option['first_column']) > len(longest_option):
			longest_option = option['first_column']
		usage_ends_at += 1

	for (index, line) in enumerate(snip.buffer[usage_begins_at:usage_ends_at]):
		option = parse_docopt_option(line, tab_width)
		print(index, option)
		snip.buffer[usage_begins_at+index] = \
			option['first_column'].ljust(len(longest_option)) + \
			'  ' + \
			option['second_column']

	snip.cursor.set(snip.cursor[0], len(snip.buffer[snip.cursor[0]]))

def parse_docopt_option(line, tab_width=4):
	line = line.replace("\t", ' '*tab_width)
	match = re.match(
		"""(?x)
			^(?P<first>
				(\s+)
				(
					(
						\s*?
						(--?\w+ ([= ]?(<[\w-]+>|[A-Z_]+))? )
					)+
				)?
			)
			\s+
			(?P<second>.+)
		""",
		line
	)

	result = {
		'first_column': match.group('first'),
		'second_column': match.group('second'),
	}

	if result['first_column'].strip() == '':
		result['first_column'] = ''

	return result
endglobal

snippet - "docopt command declaration" "is_inside_docopt_section(snip, 'usage')" beA
\$0 -$1
endsnippet

post_jump "if snip.tabstop == 0: docopt_format_options(snip)"
snippet - "docopt option declaration" "is_inside_docopt_section(snip, 'options')" beA
-$1  $2
endsnippet

snippet [ "docopt option default" "is_inside_docopt_section(snip, 'options')" eA
[default: $1]
endsnippet

snippet "(\w)=" ":=" "not is_syntax_string(to_vim_cursor(snip.cursor))" iAre
`!p snip.rv = match.group(1) + " = "`
endsnippet

snippet "=(\s)" ":=" iAr
`!p snip.rv = "=" + match.group(1)`
endsnippet

snippet "=(\S)" ":=" "not is_syntax_string(to_vim_cursor(snip.cursor))" iAr
`!p snip.rv = "= " + match.group(1)`
endsnippet

priority 2
snippet "= =" "" Ai
`!p snip.rv="== "`
endsnippet

snippet "= \" "wut" Ai
`!p snip.rv=":= "`
endsnippet

snippet ,- "underscore" iA
, _
endsnippet


global !p
def gocode_complete_function(snip):
	(snip_ret, snip_func) = get_gocode_complete(False)
	snip_full = get_gocode_complete(True)

	cur_line = re.sub('\w+\.\w+$', '', snip.buffer[snip.line])
	snip.buffer[snip.line] = cur_line

	prev_line = get_prev_nonempty_line(snip.buffer, snip.line)

	if prev_line[-1] == ',' or prev_line[-1] == '(' or prev_line[-1] == '&' or cur_line.strip() != '':
		snip.expand_anon(snip_func)
		return


	matches = re.search('\${(\d+):error}', snip_ret)
	if not matches:
		snip.expand_anon(snip_full)
		return

	placeholder_err = matches.group(1)
	snip_full = snip_full.replace(
		'${'+placeholder_err+':error}',
		'${'+placeholder_err+':err}',
	)

	actions = {
		'post_jump': """placeholder_err = """+placeholder_err +"""
if snip.tabstop == 0:
	err = snip.tabstops[placeholder_err].current_text
	if err != '_':
		snip.expand_anon("\\nif " + err + " != nil {\\n\\t$1\\n}")
"""
	}

	snip.expand_anon(
		snip_full,
		actions = actions,
	)
endglobal

pre_expand "gocode_complete_function(snip)"
snippet "(\w+\.\w+)" "gocode complete" "gocode_can_complete()" re
endsnippet

snippet "^hf" "http handle func" brA
func $1(response http.ResponseWriter, request *http.Request) {
	$2
}
endsnippet

snippet args[ "args[blah]" wA
args[`!p snip.rv = '"<' if not t[1].startswith('-') else '"'`$1`!p snip.rv = '>' if not t[1].startswith('-') else ''`"].(${2:string})
endsnippet

snippet "if s" "if os.Stat" rb
if ${1:_}, err := os.Stat($2); ${3:err != nil}
endsnippet

snippet "return fmt" "return fmt Errorf" br
return fmt.Errorf(
	"$1", $2
)
endsnippet
