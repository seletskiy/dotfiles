#global !p
#import px.cursor
#import px.langs.go
#endglobal

#snippet "^n" "func" brA
#func $1($2) $3${3/.+/ /}{
#    $4
#}
#endsnippet

#snippet "^s" "type struct" brA
#`!p
#if re.match("^([\w\[\]{}]*)$", t[2]):
#    type_left = " "
#    type_right = ""
#else:
#    type_left = " struct {\n\t"
#    type_right = "\n}"
#    if re.match("^\w+\(\)", t[2]):
#        type_left = " interface {\n\t"
#`type $1`!p snip.rv=type_left`$2`!p snip.rv=type_right`$0
#endsnippet

#priority 20
#snippet "^p" "package" "snip.buffer.name.endswith('main.go')" brAe
#package main

#$0
#endsnippet

#priority 10
#snippet "^p" "package" brA
#package ${1:`!p snip.rv=guess_package_name_from_file_name(snip.fn)`}

#$0
#endsnippet

#priority 1
#snippet te "func Test"
#func Test$1(t *testing.T) {
#    $2
#}
#endsnippet

#snippet i "if "
#if ${1:`!p snip.rv=px.snippets.complete_identifier_for_placeholder(snip.c)`} {
#    ${2:${VISUAL}}
#}
#endsnippet

#snippet ii "if <VISUAL>"
#if ${VISUAL} {
#    $2
#}
#endsnippet

#snippet q "if err != nil"
#if err != nil {
#    return err
#}
#endsnippet

#snippet qq "if err != nil"
#if err != nil {
#    return ${1:nil}, err
#}
#endsnippet


#snippet qp "if err != nil panic"
#if err != nil {
#    panic(err)
#}
#endsnippet

#snippet qn "if ... == nil"
#if ${1:`!p snip.rv=get_last_defined_var_for_snippet()`} == nil {
#    ${0:${VISUAL}}
#}
#endsnippet

#snippet r "return"
#return 
#endsnippet

#snippet r "return" "re.match('^\s+if err ', get_prev_nonempty_line(snip.buffer, snip.line))" eb
#return err
#endsnippet

#snippet p "panic" "re.match('^\s+if err ', get_prev_nonempty_line(snip.buffer, snip.line))" ebA
#panic(err)
#endsnippet

#snippet fs "... string" i
#$1 string
#endsnippet

#snippet exp "test expected"
#actual := ${1:"Something"}
#if actual != ${2:"Actual"} {
#    t.Fatalf("unexpected %#v", actual)
#}
#endsnippet

#snippet ci "const iota"
#const (
#    ${1:CONSTANT} = iota$2
#)
#endsnippet

#snippet ass "anon struct with fields" w
#struct {
#    $1
#}{
#    $2
#}
#endsnippet

#snippet "((\w+)\s*(\w+)) js$" "json annotation" br
#`!p snip.rv=match.group(1)` \`json:"${1:`!p
#snip.rv=convert_camelcase_to_snakecase(match.group(2))`}"\`
#endsnippet

#snippet "^m" "func main" rbA
#func main() {
#    $2
#}
#endsnippet

#snippet fas "anon struct"
#${1:Name} struct {
#    $2
#}
#endsnippet

#snippet fi "field int" i
#${1:Name} int
#endsnippet

#snippet fb "field bool" i
#${1:Name} bool
#endsnippet

#snippet mp "map" i
#map[${1:string}]${2:interface}
#endsnippet

#snippet msi "map[string]interface" w
#map[string]interface{}
#endsnippet

#snippet w "switch"
#switch ${1:`!p snip.rv=get_last_defined_var_for_snippet()`} {
#case ${2:true}:
#    $3
#}
#endsnippet

#snippet ww "switch true"
#switch {
#case ${1}:
#    $1
#}
#endsnippet

#snippet f "for range"
#for ${1:_}, ${2:val} := range ${3:`!p snip.rv=get_last_defined_var_for_snippet()`} {
#    ${0:${VISUAL}}
#}
#endsnippet

#snippet p "log.Printf(%#v with filename"
#log.Printf("`!p snip.rv=path+":"+str(vim.current.window.cursor[0])` %#v", $1)
#endsnippet

#snippet l "package main" "snip.cursor[0] == 0" Ae
#package main

#import "fmt"

#func main() {
#    $1
#}
#endsnippet

#snippet af "anon func" i
#func($1) $2{
#    ${3:${VISUAL}}
#}
#endsnippet

#snippet v "var ="
#var $1 = 
#endsnippet

#snippet vr "var ("
#var (
#    ${0:${VISUAL/(?m)^(\s*)var /$1/g}}
#)
#endsnippet

#global !p
#def is_in_switch_statement(snip):
#    return match_higher_indent(snip.buffer, snip.cursor, "(?i)(switch|case)")
#endglobal

#snippet "\tc" "case" "is_in_switch_statement(snip)" bre
#case $1:
#    $2
#endsnippet

#snippet c "continue" "re.match('^\s+if ', get_prev_nonempty_line(snip.buffer, snip.line))" eb
#continue
#endsnippet

#snippet rn "return nil"
#return nil
#endsnippet

#snippet u "append" i
#${1:`!p snip.rv=get_last_defined_var_for_snippet()`} = append($1, $2)
#endsnippet

#snippet ms "make slice" i
#make([]$1, ${2:0})
#endsnippet

#snippet mc "make chan" i
#make(chan $1, ${2:0})
#endsnippet

#snippet mm "make map" i
#make(map[${1:string}]${2:interface\{\}})
#endsnippet

#snippet nn "!= nil" i
#${1:${VISUAL}} != nil
#endsnippet

#snippet if "interface" i
#interface{}
#endsnippet

#snippet ts "type switch"
#switch ${1:newVar} := ${2:checkVar}.(type) {
#case ${3:Type}:
#    $4
#}
#endsnippet

#snippet , "return ... , nil" "is_return_argument(snip.buffer, snip.line, snip.column)" ie
#, `!p if is_in_err_condition(vim.current.buffer, vim.current.window.cursor[0], vim.current.window.cursor[1]):
#    snip.rv = "err"
#else:
#    snip.rv = "nil"`
#endsnippet

#snippet n, ", nil" i
#nil, 
#endsnippet

#snippet o "forever"
#for {
#    $1
#}
#endsnippet

#snippet ae "blah, err := "
#${1:data}, err := 
#endsnippet

#snippet a "blah := "
#${1:data} := 
#endsnippet


#snippet qt
#if err != nil {
#    t.Fatal(err)
#}
#endsnippet

#snippet qf
#if err != nil {
#    log.Fatalf(\`$1: %s\`, $2, err)
#}
#endsnippet

#snippet rt "return true"
#return true
#endsnippet

#snippet rf "return false"
#return false
#endsnippet

#snippet "^}(.)$" "define method" rwA
#`!p snip.rv = "}\n\n"
#`func (`!p snip.rv=' *'.join(extract_prev_method_binding_for_cursor())`) `!p snip.rv = match.group(1)`$1($2) $3${3/.+/ /}{
#    $4
#}
#endsnippet

#snippet re "return errors.New"
#return errors.New($1)
#endsnippet

#priority 10
#snippet y "error"
#error
#endsnippet

#priority 1
#snippet lf "log.Printf"
#log.Printf($1)
#endsnippet

#snippet ln "fmt.Println" bwA
#`!p
#left = '('
#right = ')'
#if " " in t[1] and not '"' in t[1]:
#    left = '("'
#    right = '")'
#`fmt.Println`!p snip.rv=left`$1`!p snip.rv=right`
#endsnippet

#snippet td "todo"
#// @TODO: 
#endsnippet

#snippet snip.line "last slice usage" i
#${1:`!p snip.rv=get_previous_slice_usage()`}[$2]
#endsnippet

#snippet t "Description" b
#var $1 = $2
#endsnippet

#snippet co "continue"
#continue
#endsnippet

#snippet } "else" "is_if_bracket(snip.buffer, snip.line, snip.column)" ew
#} else {
#    $1
#}
#endsnippet

#snippet i "if err != nil" "re.match('^\s+[^=]*err\s*:?=', snip.buffer[snip.line-1])" e
#if err != nil {
#    $1
#}
#endsnippet

#snippet "(func\s.*\)\s+)([\w\d_\s\{\}\[\]\*\.]+),\s?([\w\d_\s\{\}\[\]\*\.]+)" "return multiple" r
#`!p snip.rv=match.group(1)`(`!p snip.rv=match.group(2)`, `!p snip.rv=match.group(3)`)
#endsnippet

#snippet go "go func" b
#go func() {
#    ${1:${VISUAL}}
#}()
#endsnippet

#snippet "}(.)" "else" "is_if_bracket(snip.buffer, snip.line, snip.column-1)" rebA
#} else {
#    `!p snip.rv = match.group(1)`$1
#}
#endsnippet


#snippet lp "log.Println" wA
#`!p
#left = '('
#right = ')'
#if " " in t[1] and not '"' in t[1]:
#    left = '("'
#    right = '")'
#`log.Println`!p snip.rv=left`$1`!p snip.rv=right`
#endsnippet

#snippet "(\w)=" ":=" "not is_syntax_string(to_vim_cursor(snip.cursor))" iAre
#`!p snip.rv = match.group(1) + " = "`
#endsnippet

#snippet "=(\s)" ":=" iAr
#`!p snip.rv = "=" + match.group(1)`
#endsnippet

#snippet "=(\S)" ":=" "not is_syntax_string(to_vim_cursor(snip.cursor))" iAr
#`!p snip.rv = "= " + match.group(1)`
#endsnippet

#priority 2
#snippet "= =" "" Ai
#`!p snip.rv="== "`
#endsnippet

#snippet "= \" "wut" Ai
#`!p snip.rv=":= "`
#endsnippet

#snippet ,, "underscore" iA
#, _
#endsnippet


#global !p
#def gocode_complete_function(snip):
#    (snip_ret, snip_func) = get_gocode_complete(False)
#    snip_full = get_gocode_complete(True)

#    cur_line = re.sub('\w+\.\w+$', '', snip.buffer[snip.line])
#    snip.buffer[snip.line] = cur_line

#    prev_line = get_prev_nonempty_line(snip.buffer, snip.line)

#    if prev_line[-1] == ',' or prev_line[-1] == '(' or prev_line[-1] == '&' or cur_line.strip() != '':
#        snip.expand_anon(snip_func)
#        return


#    matches = re.search('\${(\d+):error}', snip_ret)
#    if not matches:
#        snip.expand_anon(snip_full)
#        return

#    placeholder_err = matches.group(1)
#    snip_full = snip_full.replace(
#        '${'+placeholder_err+':error}',
#        '${'+placeholder_err+':err}',
#    )

#    actions = {
#        'post_jump': """placeholder_err = """+placeholder_err +"""
#if snip.tabstop == 0:
#    err = snip.tabstops[placeholder_err].current_text
#    if err != '_':
#        snip.expand_anon("\\nif " + err + " != nil {\\n\\t$1\\n}")
#"""
#    }

#    snip.expand_anon(
#        snip_full,
#        actions = actions,
#    )
#endglobal

#pre_expand "gocode_complete_function(snip)"
#snippet "(\w+\.\w+)" "gocode complete" "gocode_can_complete()" re
#endsnippet

#snippet "^hf" "http handle func" brA
#func $1(response http.ResponseWriter, request *http.Request) {
#    $2
#}
#endsnippet

#global !p
#def fix_matchem(char):
#    vim.eval('MatchemMatchDelete("{}")'.format(char))
#    end = snip.snippet_end
#    snip.buffer[end[0]] = str(snip.buffer[end[0]][:end[1]]) + str(snip.buffer[end[0]][end[1]+1:])
#endglobal

#post_expand "fix_matchem('[')"
#snippet args[ "args[blah]" wA
#args[`!p snip.rv = '"<' if not t[1].startswith('-') else '"'`$1`!p snip.rv = '>' if not t[1].startswith('-') else ''`"].(${2:string})$0
#endsnippet

#snippet "if s" "if os.Stat" rb
#if ${1:_}, err := os.Stat($2); ${3:err != nil}
#endsnippet

#snippet "return fmt" "return fmt Errorf" br
#return fmt.Errorf(
#    "$1", $2
#)
#endsnippet

#global !p
#from UltiSnips import UltiSnips_Manager
#def expand_snip(snip, name):
#   line = snip.buffer[snip.line]
#   snip.buffer[snip.line:snip.line] = [line[:snip.column] + name + line[snip.column:]]
#endglobal
