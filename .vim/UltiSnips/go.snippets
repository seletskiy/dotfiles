global !p
# see ~/.vim/pythonx/go.py
import go
endglobal

snippet n "func"
func $1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet s "type struct"
type $1 struct {
	$2
}
endsnippet

snippet t "type"
type ${1:TypeName} ${2:description}
endsnippet

snippet pa "package"
package ${1:`!p snip.rv=go.guess_package_name_from_file_name(snip.fn)`}
endsnippet

snippet te "func Test"
func Test$1(t *testing.T) {
	$2
}
endsnippet

snippet ti "interface"
type $1 interface {
	$2
}
endsnippet

snippet i "if "
if ${1:`!p snip.rv=go.get_last_var_for_snippet()`} {
	${2:${VISUAL}}
}
endsnippet

snippet ii "if <VISUAL>"
if ${VISUAL} {
	$2
}
endsnippet

snippet q "if err != nil"
if err != nil {
	return err
}
endsnippet

snippet qq "if err != nil"
if err != nil {
	return ${1:nil}, err
}
endsnippet


snippet qp "if err != nil panic"
if err != nil {
	panic(err)
}
endsnippet

snippet qn "if ... == nil"
if ${1:`!p snip.rv=go.get_last_var_for_snippet()`} == nil {
	${0:${VISUAL}}
}
endsnippet

snippet r "return"
return 
endsnippet

snippet fs "... string" i
$1 string
endsnippet

snippet exp "test expected"
actual := ${1:"Something"}
if actual != ${2:"Actual"} {
	t.Fatalf("unexpected %#v", actual)
}
endsnippet

snippet e "else" w
 else {
	${0:${VISUAL}}
}
endsnippet

snippet ci "const iota"
const (
	${1:CONSTANT} = iota$2
)
endsnippet

snippet ass "anon struct with fields" w
struct {
	$1
}{
	$2
}
endsnippet

snippet "((\w+)\s*(\w+)) js$" "json annotation" br
`!p snip.rv=match.group(1)` \`json:"`!p
	snip.rv=go.convert_camelcase_to_snakecase(match.group(2))`"\`
endsnippet

snippet fm "func main"
func main() {
	$2
}
endsnippet

snippet fas "anon struct"
${1:Name} struct {
	$2
}
endsnippet

snippet fi "field int" i
${1:Name} int
endsnippet

snippet fb "field bool" i
${1:Name} bool
endsnippet

snippet mp "map" i
map[${1:string}]${2:interface}
endsnippet

snippet msi "map[string]interface" w
map[string]interface{}
endsnippet

snippet w "switch"
switch ${1:`!p snip.rv=go.get_last_var_for_snippet()`} {
case ${2:true}:
	$3
}
endsnippet

snippet ww "switch true"
switch {
case ${1}:
	$1
}
endsnippet

snippet f "for range"
for ${1:_}, ${2:val} := range ${3:`!p snip.rv=go.get_last_var_for_snippet()`} {
	${0:${VISUAL}}
}
endsnippet

snippet p "log.Printf(%#v with filename"
log.Printf("`!p snip.rv=path+":"+str(vim.current.window.cursor[0])` %#v", $1)
endsnippet

snippet play "package main"
package main

import "fmt"

func main() {
	$1
}
endsnippet

snippet omit "omit section"
// OMIT
${0:${VISUAL}}
// END OMIT
endsnippet

snippet af "anon func" i
func($1) $2{
	${3:${VISUAL}}
}
endsnippet

snippet v "var ="
var $1 = 
endsnippet

snippet vr "var ("
var (
	${0:${VISUAL/(?m)^(\s*)var /$1/g}}
)
endsnippet

snippet c "case"
case $1:
	$2
endsnippet

snippet rn "return nil"
return nil
endsnippet

snippet u "append" i
${1:`!p snip.rv=go.get_last_var_for_snippet()`} = append($1, $2)
endsnippet

snippet ms "make slice" i
make([]$1, ${2:0})
endsnippet

snippet mc "make chan" i
make(chan $1, ${2:0})
endsnippet

snippet mm "make map" i
make(map[${1:string}]${2:interface\{\}})
endsnippet

snippet nn "!= nil" i
${1:${VISUAL}} != nil
endsnippet

snippet if "interface" i
interface{}
endsnippet

snippet ts "type switch"
switch ${1:newVar} := ${2:checkVar}.(type) {
case ${3:Type}:
	$4
}
endsnippet

snippet ,n ", nil" i
, nil
endsnippet

snippet n, ", nil" i
nil, 
endsnippet

snippet o "forever"
for {
	$1
}
endsnippet

snippet ae "blah, err := "
${1:data}, err := 
endsnippet

snippet a "blah := "
${1:data} := 
endsnippet


snippet qt
if err != nil {
	t.Fatal(err)
}
endsnippet

snippet qf
if err != nil {
	log.Fatalf(\`$1: %s\`, $2, err)
}
endsnippet

snippet fweb "web handler"
func ${1:HandleSmthing}(w http.ResponseWriter, req *http.Request) {
	$2
}
endsnippet

snippet rt "return true"
return true
endsnippet

snippet rf "return false"
return false
endsnippet

snippet "(}|d)" "define method" "go.is_struct_bracket(b, l, c)" xrw
`!p if match.group(1) == "}":
	snip.rv = "}\n\n"
`func (`!p snip.rv=' '.join(go.extract_prev_method_binding_for_cursor())`) $1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet dp "define method on pointer"
func (`!p snip.rv=' *'.join(go.extract_prev_method_binding_for_cursor())`) $1($2) $3${3/.+/ /}{
	$4
}
endsnippet

snippet re "return errors.New"
return errors.New($1)
endsnippet

snippet y "error"
error
endsnippet

snippet lf "log.Printf"
log.Printf($1)
endsnippet

snippet td "todo"
// @TODO: 
endsnippet

snippet l "last slice usage" i
${1:`!p snip.rv=go.get_previous_slice_usage()`}[$2]
endsnippet

snippet t "Description" !b
var $1 = $2
endsnippet

snippet co "continue"
continue
endsnippet

snippet u "last variable usage" w
${1:`!p snip.rv=go.get_previous_declared_var()`}
endsnippet

snippet L "loc"
"$1": &Location{
	$2
},
endsnippet

snippet } "else" "go.is_if_bracket(b, l, c)" xw
} else {
       $1
}
endsnippet

snippet i "if err != nil" "re.match('^\s+[^=]*err\s*:?=', b[l-2])" x
if err != nil {
       $1
}
endsnippet
